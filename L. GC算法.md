## GC算法
JavaScript使用垃圾回收机制来自动管理内存。垃圾回收是一把双刃剑，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因 长时间运转而带来的内存泄露问题。

但使用了垃圾回收即意味着程序员将无法掌控内存。ECMAScript没有暴露任何垃圾回收器的接口

### 引用计数法
对每一次引用，都会+1 ；至0 的时候，清除掉
存在问题： 
相互引用会引发内存泄漏的问题
优点：
<1>可即时回收垃圾：在该方法中，每个对象始终知道自己是否有被引用，当被引用的数值为0时，对象马上可以把自己当作空闲空间链接到空闲链表。
<2>最大暂停时间短。
<3>没有必要沿着指针查找
缺点： 
<1>计数器值的增减处理非常繁重
<2>计算器需要占用很多位。
<3>实现繁琐。
<4>循环引用无法回收。

###  宿主环境对堆区处理的标记变量法
两个阶段：标记就是把所有活动对象都做上标记的阶段；清除就是将没有做上标记的对象进行回收的阶段。
打上标记 。    只要还有来自栈的引用 =>就不清除标记 ; 否则的话就清除标记 ; 
以前版本的存在问题: 
栈开启的的时候，同时声明； 栈结束的时候，没有标记的会同时清除。=》在声明和清除的时候，cpu占用率飙高； 

新版本： 
新增了 老生区和新生区两个分区，对于新声明的变量，会存放在新生区，然后再栈结束的时候，会先把新生区的无标记内容放到老生区。然后进行处理。 
优点
实现简单=>在每个字末位预留一位来标记这个字段是指针还是数据。这种方法需要编译器支持。
解决了相互引用(循环引用)的问题
3、缺点
<1>碎片化：在回收的过程中会产生被细化的分块，到后面，即使堆中分块的总大小够用，但是却因为分块太小而不能执行分配。

<2>分配速度：因为分块不是连续的，因此每次分块都要遍历空闲链表，找到足够大的分块，从而造成时间的浪费。

<3>与写时复制技术不兼容：所谓写时复制就是fork的时候，内存空间只引用而不复制，只有当该进程的数据发生变化时，才会将数据复制到该进程的内存空间。这样，当两个进程中的内存数据相同的时候，就能节约大量的内存空间了。而对于标记-清除算法，它的每个对象都有一个标志位来表示它是否被标记，在每一次运行标记-清除算法的时候，被引用的对象都会进行标记操作，这个仅仅标记位的改变，也会变成对象数据的改变，从而引发写时复制的复制过程，与写时复制的初衷就背道而驰了。

### 复制算法
复制算法就是将内存空间按容量分成两块。当这一块内存用完的时候，就将还存活着的对象复制到另外一块上面，然后把已经使用过的这一块一次清理掉。这样使得每次都是对半块内存进行内存回收。内存分配时就不用考虑内存碎片等复杂情况，只要移动堆顶的指针，按顺序分配内存即可，实现简单，运行高效

### v8引擎   准确式GC
js是一门具有自动回收垃圾收集的编程语言，在浏览器中主要是通过标记清除的方法回收垃圾，在nodejs中主要是通过准确式GC=》分代回收，Scavenge，标记清除，增量标记等算法来回收垃圾。在日常开发中，有一些不引入注意的书写方式可能会导致内存泄露，多注意自己代码规范。

V8在执行垃圾回收时会阻塞 JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）

V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。

 1  通过 指针标记法 区别 数据还是引用   因为 => 见背景
 2 回收策略： 
 分代回收策略 ，将内存分为两个生代： 新生代和老生代 。

新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用 不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件时，会被移动到老生代（晋升）

条件： 
1、新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。

2、To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。

#### 新生代算法
Scavenge算法 具体实现：  复制的方式的方法–cheney算法 
在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。
#### 老生代的算法
老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是 标记清除算法 和 标记压缩算法 。


### chrome V8的堆构成
V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：

1、新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁；

2、老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里；

3、老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针；

4、大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象；

5、代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区；

6、Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单。

### 背景
垃圾回收器需要面临一个问题，它需要判断哪些是数据，哪些是指针。由于很多垃圾回收算法会将对象在内存中移动（紧凑，减少内存碎片），所以经常需要进行指针的改写

### 指针的识别
1. 保守法：将所有堆上对齐的字都认为是指针，那么有些数据就会被误认为是指针。于是某些实际是数字的假指针，会背误认为指向活跃对象，导致内存泄露（假指针指向的对象可能是死对象，但依旧有指针指向——这个假指针指向它）同时我们不能移动任何内存区域。

2. 编译器提示法：如果是静态语言，编译器能够告诉我们每个类当中指针的具体位置，而一旦我们知道对象时哪个类实例化得到的，就能知道对象中所有指针。这是JVM实现垃圾回收的方式，但这种方式并不适合JS这样的动态语言

3. 标记指针法：这种方法需要在每个字末位预留一位来标记这个字段是指针还是数据。这种方法需要编译器支持，但实现简单，而且性能不错。V8采用的是这种方式。V8将所有数据以32bit字宽来存储，其中最低一位保持为0，而指针的最低两位为01